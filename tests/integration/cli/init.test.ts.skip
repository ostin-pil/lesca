import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { mkdtempSync, rmSync, existsSync, readFileSync } from 'fs'
import { tmpdir } from 'os'
import { join } from 'path'

describe('CLI: init', () => {
  let tempDir: string
  let configPath: string
  let initCommand: any
  let mockExit: any

  beforeEach(async () => {
    tempDir = mkdtempSync(join(tmpdir(), 'lesca-cli-init-test-'))
    configPath = join(tempDir, 'lesca.config.yaml')

    // Mock dependencies before importing the command
    vi.doMock('inquirer', () => ({
      default: {
        prompt: vi.fn(),
      },
    }))

    vi.doMock('ora', () => ({
      default: () => ({
        start: vi.fn().mockReturnThis(),
        succeed: vi.fn().mockReturnThis(),
        fail: vi.fn().mockReturnThis(),
        text: '',
      }),
    }))

    vi.doMock('chalk', () => ({
      default: {
        gray: (str: string) => str,
        cyan: (str: string) => str,
        white: (str: string) => str,
        red: (str: string) => str,
        yellow: (str: string) => str,
        green: (str: string) => str,
        bold: (str: string) => str,
      },
    }))

    mockExit = vi.spyOn(process, 'exit').mockImplementation((() => {}) as any)

    // Dynamic import of the command
    const module = await import('@lesca/cli/commands/init')
    initCommand = module.initCommand
  })

  afterEach(() => {
    if (existsSync(tempDir)) {
      rmSync(tempDir, { recursive: true, force: true })
    }
    vi.clearAllMocks()
    vi.resetModules()
  })

  it('should create configuration file with default values', async () => {
    const inquirer = await import('inquirer')
    // Mock user answers
    vi.mocked(inquirer.default.prompt).mockResolvedValue({
      configPath,
      outputDir: join(tempDir, 'output'),
      format: 'markdown',
      cookiePath: join(tempDir, 'cookies.json'),
      force: false,
    })

    await initCommand.parseAsync(['node', 'lesca', 'init'])

    expect(existsSync(configPath)).toBe(true)
    const content = readFileSync(configPath, 'utf-8')
    expect(content).toContain('output:')
    expect(content).toContain('format: markdown')
  })

  it('should respect CLI options over defaults', async () => {
    const inquirer = await import('inquirer')
    vi.mocked(inquirer.default.prompt).mockResolvedValue({
      configPath,
      outputDir: join(tempDir, 'custom-output'),
      format: 'obsidian',
      cookiePath: join(tempDir, 'custom-cookies.json'),
      force: true,
    })

    await initCommand.parseAsync([
      'node',
      'lesca',
      'init',
      '--output-dir',
      join(tempDir, 'custom-output'),
      '--format',
      'obsidian',
    ])

    expect(existsSync(configPath)).toBe(true)
    const content = readFileSync(configPath, 'utf-8')
    expect(content).toContain('format: obsidian')
  })

  it('should handle existing config without force', async () => {
    // Create dummy config
    const fs = await import('fs')
    fs.writeFileSync(configPath, 'dummy: true')

    const inquirer = await import('inquirer')
    vi.mocked(inquirer.default.prompt).mockResolvedValue({
      configPath,
      force: false,
    })

    await initCommand.parseAsync(['node', 'lesca', 'init', '--config-path', configPath])

    expect(mockExit).toHaveBeenCalledWith(1)

    const content = readFileSync(configPath, 'utf-8')
    expect(content).toBe('dummy: true')
  })
})
